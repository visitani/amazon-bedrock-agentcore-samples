AWSTemplateFormatVersion: "2010-09-09"
Description: "CloudFormation template for Customer Support System with DynamoDB tables, SSM parameters, and synthetic data"
Resources:
  AgentCoreRuntimeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: AgentCoreRuntimeExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*'
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'
              - Effect: Allow
                Resource: '*'
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    'cloudwatch:namespace': 'bedrock-agentcore'
              - Sid: GetAgentAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/customer*'
              - Sid: BedrockModelAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: InvokeGateway
                Effect: Allow
                Action:
                  - bedrock-agentcore:InvokeGateway
                Resource:
                  - '*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-AgentCore-Runtime-Role'
        - Key: Purpose
          Value: 'AgentCore Runtime Execution'
  
  GatewayAgentCoreRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Enhanced trust policy with security conditions to prevent confused deputy attacks
          # This ensures only gateways from your account with the specified naming pattern can assume this role
          - Sid: GatewayAssumeRolePolicy
            Effect: Allow
            Principal:
              Service:
                - bedrock-agentcore.amazonaws.com
            Action:
              - sts:AssumeRole
            Condition:
              # Ensure the request comes from the same AWS account
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              # Restrict to gateways matching the naming pattern
              # This allows any gateway starting with "customer-support-gatewat-" in the current region
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:gateway/*"
      Policies:
        - PolicyName: BedrockAgentCorePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Comprehensive policy for AgentCore Gateway operations
              # Grants permissions for gateway management, Bedrock integration, credentials, and target invocation
              - Sid: VisualEditor0
                Effect: Allow
                Action:
                  - bedrock-agentcore:*              # All AgentCore operations
                  - bedrock:*                        # All Bedrock operations
                  - agent-credential-provider:*      # Credential provider management
                  - iam:PassRole                     # Required to pass roles to services
                  - secretsmanager:GetSecretValue    # Access secrets for credentials
                  - lambda:InvokeFunction            # Invoke Lambda targets
                  - s3:*                             # S3 access for OpenAPI specs and other resources
                Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Gateway-Execution-Role'
        - Key: Purpose
          Value: 'AgentCore Gateway Execution'
  
  # DynamoDB Table for Warranty Information
  WarrantyTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: serial_number
          AttributeType: S
        - AttributeName: customer_id
          AttributeType: S
      KeySchema:
        - AttributeName: serial_number
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: customer-index
          KeySchema:
            - AttributeName: customer_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Application
          Value: CustomerSupport
        - Key: CostCenter
          Value: CustomerSupport

  # DynamoDB Table for Customer Profiles
  CustomerProfileTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: customer_id
          AttributeType: S
        - AttributeName: email
          AttributeType: S
        - AttributeName: phone
          AttributeType: S
      KeySchema:
        - AttributeName: customer_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: email-index
          KeySchema:
            - AttributeName: email
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: phone-index
          KeySchema:
            - AttributeName: phone
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Application
          Value: CustomerSupport
        - Key: CostCenter
          Value: CustomerSupport

  # Lambda function to populate synthetic data
  PopulateDataFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt PopulateDataRole.Arn
      Timeout: 120
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          from datetime import datetime, timedelta
          import random
          import uuid
          from decimal import Decimal

          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Create':
                      dynamodb = boto3.resource('dynamodb')
                      warranty_table_name = event['ResourceProperties']['WarrantyTableName']
                      customer_table_name = event['ResourceProperties']['CustomerTableName']

                      warranty_table = dynamodb.Table(warranty_table_name)
                      customer_table = dynamodb.Table(customer_table_name)

                      # Customer profile data
                      customer_data = [
                          {
                              'customer_id': 'CUST001',
                              'first_name': 'John',
                              'last_name': 'Smith',
                              'email': 'john.smith@email.com',
                              'phone': '+1-555-0101',
                              'address': {
                                  'street': '123 Main Street',
                                  'city': 'New York',
                                  'state': 'NY',
                                  'zip_code': '10001',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1985-03-15',
                              'registration_date': '2022-11-20',
                              'tier': 'Premium',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': True,
                                  'phone': False
                              },
                              'support_cases_count': 2,
                              'total_purchases': 3,
                              'lifetime_value': 2850.00,
                              'notes': 'VIP customer, prefers email communication'
                          },
                          {
                              'customer_id': 'CUST002',
                              'first_name': 'Sarah',
                              'last_name': 'Johnson',
                              'email': 'sarah.johnson@email.com',
                              'phone': '+1-555-0102',
                              'address': {
                                  'street': '456 Oak Avenue',
                                  'city': 'Los Angeles',
                                  'state': 'CA',
                                  'zip_code': '90210',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1990-07-22',
                              'registration_date': '2023-03-15',
                              'tier': 'Standard',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': False,
                                  'phone': True
                              },
                              'support_cases_count': 1,
                              'total_purchases': 1,
                              'lifetime_value': 1299.99,
                              'notes': 'Tech-savvy customer, quick to resolve issues'
                          },
                          {
                              'customer_id': 'CUST003',
                              'first_name': 'Mike',
                              'last_name': 'Davis',
                              'email': 'mike.davis@email.com',
                              'phone': '+1-555-0103',
                              'address': {
                                  'street': '789 Pine Street',
                                  'city': 'Chicago',
                                  'state': 'IL',
                                  'zip_code': '60601',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1988-12-03',
                              'registration_date': '2023-08-10',
                              'tier': 'Gold',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': True,
                                  'phone': True
                              },
                              'support_cases_count': 0,
                              'total_purchases': 2,
                              'lifetime_value': 549.98,
                              'notes': 'Audio enthusiast, interested in premium products'
                          },
                          {
                              'customer_id': 'CUST004',
                              'first_name': 'Emily',
                              'last_name': 'Brown',
                              'email': 'emily.brown@email.com',
                              'phone': '+1-555-0104',
                              'address': {
                                  'street': '321 Elm Drive',
                                  'city': 'Houston',
                                  'state': 'TX',
                                  'zip_code': '77001',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1992-04-18',
                              'registration_date': '2022-09-05',
                              'tier': 'Standard',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': False,
                                  'phone': False
                              },
                              'support_cases_count': 3,
                              'total_purchases': 1,
                              'lifetime_value': 399.99,
                              'notes': 'Fitness enthusiast, uses wearables frequently'
                          },
                          {
                              'customer_id': 'CUST005',
                              'first_name': 'Robert',
                              'last_name': 'Wilson',
                              'email': 'robert.wilson@email.com',
                              'phone': '+1-555-0105',
                              'address': {
                                  'street': '654 Maple Lane',
                                  'city': 'Phoenix',
                                  'state': 'AZ',
                                  'zip_code': '85001',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1983-09-11',
                              'registration_date': '2023-10-12',
                              'tier': 'Premium',
                              'communication_preferences': {
                                  'email': False,
                                  'sms': True,
                                  'phone': True
                              },
                              'support_cases_count': 1,
                              'total_purchases': 1,
                              'lifetime_value': 699.99,
                              'notes': 'Gaming enthusiast, prefers phone support'
                          }
                      ]

                      # Warranty data with customer_id references
                      warranty_data = [
                          {
                              'serial_number': 'ABC12345678',
                              'customer_id': 'CUST001',
                              'product_name': 'SmartPhone Pro Max 128GB',
                              'purchase_date': '2023-01-15',
                              'warranty_end_date': '2025-01-15',
                              'warranty_type': 'Extended Warranty',
                              'coverage_details': 'Full coverage including accidental damage, water damage, and manufacturer defects',
                              'purchase_price': 1299.99,
                              'store_location': 'New York - 5th Avenue'
                          },
                          {
                              'serial_number': 'DEF98765432',
                              'customer_id': 'CUST002',
                              'product_name': 'Laptop Ultra 15.6"',
                              'purchase_date': '2023-06-20',
                              'warranty_end_date': '2024-06-20',
                              'warranty_type': 'Standard Warranty',
                              'coverage_details': 'Hardware defects and manufacturing issues covered. Software support included',
                              'purchase_price': 1299.99,
                              'store_location': 'Los Angeles - Beverly Hills'
                          },
                          {
                              'serial_number': 'GHI11111111',
                              'customer_id': 'CUST003',
                              'product_name': 'Wireless Headphones Elite',
                              'purchase_date': '2024-02-10',
                              'warranty_end_date': '2026-02-10',
                              'warranty_type': 'Premium Warranty',
                              'coverage_details': 'Comprehensive coverage including battery replacement, driver issues, and cosmetic damage',
                              'purchase_price': 299.99,
                              'store_location': 'Chicago - Michigan Avenue'
                          },
                          {
                              'serial_number': 'JKL22222222',
                              'customer_id': 'CUST004',
                              'product_name': 'Smart Watch Series X',
                              'purchase_date': '2022-12-05',
                              'warranty_end_date': '2023-12-05',
                              'warranty_type': 'Standard Warranty',
                              'coverage_details': 'Hardware and software defects covered. Water resistance guaranteed',
                              'purchase_price': 399.99,
                              'store_location': 'Houston - Galleria'
                          },
                          {
                              'serial_number': 'MNO33333333',
                              'customer_id': 'CUST005',
                              'product_name': 'Gaming Console Pro',
                              'purchase_date': '2023-11-25',
                              'warranty_end_date': '2024-11-25',
                              'warranty_type': 'Gaming Warranty',
                              'coverage_details': 'Controller issues, overheating protection, and hard drive replacement covered',
                              'purchase_price': 699.99,
                              'store_location': 'Phoenix - Scottsdale'
                          },
                          {
                              'serial_number': 'PQR44444444',
                              'customer_id': 'CUST001',
                              'product_name': 'Tablet Air 10.9"',
                              'purchase_date': '2024-03-12',
                              'warranty_end_date': '2025-03-12',
                              'warranty_type': 'Standard Warranty',
                              'coverage_details': 'Screen defects, battery issues, and charging port problems covered',
                              'purchase_price': 599.99,
                              'store_location': 'New York - 5th Avenue'
                          },
                          {
                              'serial_number': 'STU55555555',
                              'customer_id': 'CUST001',
                              'product_name': 'Smart TV 65" OLED',
                              'purchase_date': '2023-08-30',
                              'warranty_end_date': '2025-08-30',
                              'warranty_type': 'Extended Warranty',
                              'coverage_details': 'Panel replacement, smart features, sound system, and remote control covered',
                              'purchase_price': 1999.99,
                              'store_location': 'New York - 5th Avenue'
                          },
                          {
                              'serial_number': 'VWX66666666',
                              'customer_id': 'CUST003',
                              'product_name': 'Bluetooth Speaker Pro',
                              'purchase_date': '2024-01-08',
                              'warranty_end_date': '2026-01-08',
                              'warranty_type': 'Audio Warranty',
                              'coverage_details': 'Driver replacement, battery issues, and waterproofing covered',
                              'purchase_price': 249.99,
                              'store_location': 'Chicago - Michigan Avenue'
                          }
                      ]

                      # Insert customer data
                      with customer_table.batch_writer() as batch:
                          for item in customer_data:
                              item = json.loads(json.dumps(item), parse_float=Decimal)
                              batch.put_item(Item=item)

                      # Insert warranty data
                      with warranty_table.batch_writer() as batch:
                          for item in warranty_data:
                              item = json.loads(json.dumps(item), parse_float=Decimal)
                              batch.put_item(Item=item)

                      print(f"Successfully populated {len(customer_data)} customer profiles")
                      print(f"Successfully populated {len(warranty_data)} warranty records")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})

  # IAM Role for Lambda function
  PopulateDataRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: DynamoDBWritePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:BatchWriteItem
                Resource:
                  - !GetAtt WarrantyTable.Arn
                  - !GetAtt CustomerProfileTable.Arn
        - PolicyName: AllowBasicLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
  # Custom resource to trigger Lambda function
  PopulateData:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt PopulateDataFunction.Arn
      WarrantyTableName: !Ref WarrantyTable
      CustomerTableName: !Ref CustomerProfileTable
    DependsOn:
      - WarrantyTable
      - CustomerProfileTable

  # Lambda target
  CustomerSupportLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /service-role/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
      Policies:
        - PolicyName: CustomerProfileAccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowReadCustomerProfileTable
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:DescribeTable
                Resource: !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CustomerProfileTable}

              - Sid: AllowReadCustomerTableIndexes
                Effect: Allow
                Action:
                  - dynamodb:Query
                Resource: !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${CustomerProfileTable}/index/*

        - PolicyName: WarrantyCheckAccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowReadWarrantyTable
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:DescribeTable
                Resource: !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${WarrantyTable}

  CustomerSupportLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-customer-support'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt CustomerSupportLambdaRole.Arn
      Timeout: 30
      Environment:
        Variables:
          CUSTOMER_PROFILE_TABLE_NAME: !Ref CustomerProfileTable
          WARRANTY_TABLE_NAME: !Ref WarrantyTable
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import re
          from datetime import datetime
          from botocore.exceptions import ClientError
          import logging

          # Setting logger
          logging.basicConfig(
              format="[%(asctime)s] p%(process)s {%(filename)s:%(lineno)d} %(levelname)s - %(message)s",
              level=logging.INFO,
          )
          logger = logging.getLogger(__name__)

          # Initialize clients
          dynamodb = boto3.resource("dynamodb")

          # Get table names from environment variables
          CUSTOMER_PROFILE_TABLE_NAME = os.environ.get("CUSTOMER_PROFILE_TABLE_NAME")
          WARRANTY_TABLE_NAME = os.environ.get("WARRANTY_TABLE_NAME")

          def get_named_parameter(event, name):
              if name not in event:
                  return None
              return event.get(name)

          def get_customer_profile(customer_id=None, email=None, phone=None):
              """Get customer profile information"""
              try:
                  table = dynamodb.Table(CUSTOMER_PROFILE_TABLE_NAME)

                  customer_item = None
                  search_method = ""

                  # Search by customer_id (primary key - most efficient)
                  if customer_id:
                      search_method = "Customer ID"
                      response = table.get_item(Key={"customer_id": customer_id.upper()})
                      if "Item" in response:
                          customer_item = response["Item"]

                  # Search by email using GSI
                  elif email:
                      search_method = "Email"
                      response = table.query(
                          IndexName="email-index",
                          KeyConditionExpression="email = :email",
                          ExpressionAttributeValues={":email": email.lower()},
                      )
                      if response["Items"]:
                          customer_item = response["Items"][0]

                  # Search by phone using GSI
                  elif phone:
                      search_method = "Phone"
                      normalized_phone = re.sub(r"[\s\-$$]", "", phone)
                      if not normalized_phone.startswith("+"):
                          normalized_phone = "+1-" + normalized_phone if len(normalized_phone) == 10 else phone

                      response = table.query(
                          IndexName="phone-index",
                          KeyConditionExpression="phone = :phone",
                          ExpressionAttributeValues={":phone": normalized_phone},
                      )
                      if response["Items"]:
                          customer_item = response["Items"][0]

                  if not customer_item:
                      return f"‚ùå Customer not found using {search_method}: {customer_id or email or phone}"

                  # Format customer profile response
                  customer_id_value = customer_item.get("customer_id", "Unknown")
                  first_name = customer_item.get("first_name", "Unknown")
                  last_name = customer_item.get("last_name", "Unknown")
                  email_value = customer_item.get("email", "Not provided")
                  phone_value = customer_item.get("phone", "Not provided")
                  tier = customer_item.get("tier", "Standard")
                  total_purchases = customer_item.get("total_purchases", 0)
                  lifetime_value = float(customer_item.get("lifetime_value", 0))

                  tier_emoji = {"Standard": "ü•â", "Gold": "ü•á", "Premium": "üíé", "VIP": "üëë"}.get(tier, "üë§")

                  profile_info = [
                      "üë§ Customer Profile Information",
                      "===============================",
                      f"üÜî Customer ID: {customer_id_value}",
                      f"üë§ Name: {first_name} {last_name}",
                      f"{tier_emoji} Tier: {tier}",
                      f"üìß Email: {email_value}",
                      f"üì± Phone: {phone_value}",
                      f"üõí Total Purchases: {total_purchases}",
                      f"üí∞ Lifetime Value: ${lifetime_value:,.2f}",
                  ]

                  return "\n".join(profile_info)

              except Exception as e:
                  logger.error(f"Error getting customer profile: {str(e)}")
                  return f"‚ùå Error retrieving customer profile: {str(e)}"

          def check_warranty_status(serial_number, customer_email=None):
              """Check warranty status for a product"""
              try:
                  table = dynamodb.Table(WARRANTY_TABLE_NAME)

                  # Validate serial number format
                  if not re.match(r"^[A-Z0-9]{8,20}$", serial_number.upper()):
                      return "‚ùå Invalid serial number format. Must be 8-20 alphanumeric characters."

                  serial_number = serial_number.upper()
                  response = table.get_item(Key={"serial_number": serial_number})

                  if "Item" not in response:
                      return f"‚ùå Warranty not found for serial number: {serial_number}"

                  warranty_item = response["Item"]

                  # Extract warranty information
                  product_name = warranty_item.get("product_name", "Unknown Product")
                  purchase_date = warranty_item.get("purchase_date", "Unknown")
                  warranty_end_date = warranty_item.get("warranty_end_date", "Unknown")
                  warranty_type = warranty_item.get("warranty_type", "Standard")
                  customer_name = warranty_item.get("customer_name", "Unknown")
                  coverage_details = warranty_item.get("coverage_details", "Standard coverage applies")

                  # Calculate days remaining
                  try:
                      end_date_obj = datetime.strptime(warranty_end_date, "%Y-%m-%d")
                      today = datetime.now()
                      days_remaining = (end_date_obj - today).days
                  except ValueError:
                      days_remaining = 0

                  # Determine status
                  if days_remaining > 30:
                      status_text = "‚úÖ Active"
                  elif days_remaining > 0:
                      status_text = "‚ö†Ô∏è Expiring Soon"
                  else:
                      status_text = "‚ùå Expired"

                  # Format warranty information
                  warranty_info = [
                      "üõ°Ô∏è Warranty Status Information",
                      "===============================",
                      f"üì± Product: {product_name}",
                      f"üî¢ Serial Number: {serial_number}",
                      f"üë§ Customer: {customer_name}",
                      f"üìÖ Purchase Date: {purchase_date}",
                      f"‚è∞ Warranty End Date: {warranty_end_date}",
                      f"üìã Warranty Type: {warranty_type}",
                      f"üîç Status: {status_text}",
                      f"üìÜ Days Remaining: {days_remaining if days_remaining > 0 else 'Expired'}",
                      "",
                      "üîß Coverage Details:",
                      f"   {coverage_details}",
                  ]

                  return "\n".join(warranty_info)

              except Exception as e:
                  logger.error(f"Error checking warranty status: {str(e)}")
                  return f"‚ùå Error checking warranty status: {str(e)}"

          def lambda_handler(event, context):
              print(f"Event: {event}")
              print(f"Context: {context}")

              try:
                  extended_tool_name = context.client_context.custom["bedrockAgentCoreToolName"]
                  resource = extended_tool_name.split("___")[1]

                  print(f"Resource: {resource}")

                  if resource == "get_customer_profile":
                      customer_id = get_named_parameter(event=event, name="customer_id")
                      email = get_named_parameter(event=event, name="email")
                      phone = get_named_parameter(event=event, name="phone")

                      if not customer_id and not email and not phone:
                          return {
                              "statusCode": 400,
                              "body": "‚ùå Please provide customer_id, email, or phone",
                          }

                      customer_profile = get_customer_profile(
                          customer_id=customer_id, email=email, phone=phone
                      )

                      return {
                          "statusCode": 200,
                          "body": customer_profile,
                      }

                  elif resource == "check_warranty_status":
                      serial_number = get_named_parameter(event=event, name="serial_number")
                      customer_email = get_named_parameter(event=event, name="customer_email")

                      if not serial_number:
                          return {
                              "statusCode": 400,
                              "body": "‚ùå Please provide serial_number",
                          }

                      warranty_status = check_warranty_status(
                          serial_number=serial_number, customer_email=customer_email
                      )

                      return {
                          "statusCode": 200,
                          "body": warranty_status,
                      }

                  return {
                      "statusCode": 400,
                      "body": f"‚ùå Unknown toolname: {resource}",
                  }

              except Exception as e:
                  logger.error(f"Lambda handler error: {str(e)}")
                  return {
                      "statusCode": 500,
                      "body": f"‚ùå Internal error: {str(e)}",
                  }

Outputs:
  CustomerSupportLambdaArn:
    Description: ARN of the Customer Support Lambda function
    Value: !GetAtt CustomerSupportLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-CustomerSupportLambdaArn'

  GatewayAgentCoreRoleArn:
    Description: ARN of the Gateway AgentCore IAM Role
    Value: !GetAtt GatewayAgentCoreRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-GatewayAgentCoreRoleArn'

  AgentCoreRuntimeExecutionRoleArn:
    Description: ARN of the AgentCore Runtime Execution IAM Role
    Value: !GetAtt AgentCoreRuntimeExecutionRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-AgentCoreRuntimeExecutionRoleArn'
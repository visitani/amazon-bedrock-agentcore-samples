AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bedrock AgentCore Gateway for customer support tools. Deploys Lambda functions for warranty checks and customer profile lookups, DynamoDB tables for warranty and customer data, and AgentCore Gateway with MCP protocol configuration and JWT authentication.'


Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
    - Label:
        default: 'Environment Configuration'
      Parameters:
      - Environment
    - Label:
        default: 'Stack References'
      Parameters:
      - VPCStackName
      - CognitoStackName

Parameters:
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues:
      - dev
      - test
      - prod
    Description: 'Environment name for resource naming'

  VPCStackName:
    Type: String
    Description: 'Name of the VPC stack to reference for network configuration'

  CognitoStackName:
    Type: String
    Description: 'Name of the Cognito stack to reference for authentication configuration'

Resources:
  # KMS Key for DynamoDB encryption
  GatewayDynamoDBKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: 'KMS Key for Gateway DynamoDB tables encryption'
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow DynamoDB Service
            Effect: Allow
            Principal:
              Service: dynamodb.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: '*'

  GatewayDynamoDBKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/csvpc-${Environment}-gateway-dynamodb-key'
      TargetKeyId: !Ref GatewayDynamoDBKMSKey

  GatewayAgentCoreRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - bedrock-agentcore.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: InvokeFunction
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt CustomerSupportLambda.Arn

  # IAM Role for Customer Support Lambda
  CustomerSupportLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CustomerSupportLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt WarrantyTable.Arn
                  - !GetAtt CustomerProfileTable.Arn
                  - !Sub '${CustomerProfileTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/app/customersupportvpc/*'
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource: !GetAtt GatewayDynamoDBKMSKey.Arn

  # DynamoDB Table for Warranty Information
  WarrantyTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'csvpc-${Environment}-warranty-table'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref GatewayDynamoDBKMSKey
      AttributeDefinitions:
        - AttributeName: serial_number
          AttributeType: S
      KeySchema:
        - AttributeName: serial_number
          KeyType: HASH
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-warranty-table'
        - Key: Purpose
          Value: 'Customer Support Warranty Data'

  # DynamoDB Table for Customer Profiles
  CustomerProfileTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'csvpc-${Environment}-customer-profile-table'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref GatewayDynamoDBKMSKey
      AttributeDefinitions:
        - AttributeName: customer_id
          AttributeType: S
        - AttributeName: email
          AttributeType: S
        - AttributeName: phone
          AttributeType: S
      KeySchema:
        - AttributeName: customer_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: email-index
          KeySchema:
            - AttributeName: email
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: phone-index
          KeySchema:
            - AttributeName: phone
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-customer-profile-table'
        - Key: Purpose
          Value: 'Customer Support Profile Data'

  # IAM Role for Gateway Management Lambda
  GatewayManagementLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: GatewayManagementPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListGateways
                  - bedrock-agentcore:ListGatewayTargets
                  - bedrock-agentcore:GetGateway
                  - bedrock-agentcore:GetGatewayTarget
                  - bedrock-agentcore:CreateGateway
                  - bedrock-agentcore:CreateGatewayTarget
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:gateway/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:gateway-target/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:DeleteGateway
                  - bedrock-agentcore:DeleteGatewayTarget
                  - bedrock-agentcore:UpdateGateway
                  - bedrock-agentcore:UpdateGatewayTarget
                  - bedrock-agentcore:SynchronizeGatewayTargets
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:gateway/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:gateway-target/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                  - ssm:PutParameter
                  - ssm:DeleteParameter
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/app/customersupportvpc/*'
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt GatewayAgentCoreRole.Arn
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientSecret'
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-SecretsManagerKMSKeyArn'
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'

  CustomerSupportGateway:
    Type: AWS::BedrockAgentCore::Gateway
    Properties:
      Name: !Sub '${Environment}-customer-support-vpc'
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientId'
          DiscoveryUrl: !Sub
            - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
            - UserPoolId:
                Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'
      AuthorizerType: "CUSTOM_JWT"
      Description: "Customer Support Gateway for warranty checks and customer profile lookups"
      ProtocolConfiguration:
        Mcp:
          SearchType: "SEMANTIC"
      ProtocolType: "MCP"
      RoleArn: !GetAtt GatewayAgentCoreRole.Arn
      Tags:
        Name: !Sub 'csvpc-${Environment}-CustomerSupportGateway'
        Environment: !Ref Environment

  # Lambda Execution Role for X-Ray Traces Setup
  XRayTracesSetupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:PutDeliverySource
                  - logs:DeleteDeliverySource
                  - logs:PutDeliveryDestination
                  - logs:DeleteDeliveryDestination
                  - logs:CreateDelivery
                  - logs:DeleteDelivery
                  - logs:GetDeliverySource
                  - logs:GetDeliveryDestination
                  - logs:GetDelivery
                  - logs:DescribeDeliveries
                  - logs:DescribeDeliveryDestinations
                  - logs:DescribeDeliverySources
                  - logs:PutSubscriptionFilter
                  - logs:GetSubscriptionFilter
                  - logs:DeleteSubscriptionFilter
                  - logs:PutDeliveryDestinationPolicy
                  - logs:GetDeliveryDestinationPolicy
                  - logs:DeleteDeliveryDestinationPolicy
                Resource: '*'
        - PolicyName: AgentCoreDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:AllowVendedLogDeliveryForResource
                Resource: '*'
        - PolicyName: XRayAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                  - xray:GetSamplingStatisticSummaries
                  - xray:PutResourcePolicy
                  - xray:ListResourcePolicies
                Resource: '*'
        - PolicyName: IAMPassRolePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: '*'
                Condition:
                  StringEquals:
                    'iam:PassedToService': 'logs.amazonaws.com'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Role'
        - Key: Purpose
          Value: 'X-Ray Traces Setup Lambda'

  # Lambda Function for X-Ray Traces Setup
  XRayTracesSetupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-customer-support-gateway-xray-traces-setup'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt XRayTracesSetupLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          RESOURCE_ID: !GetAtt CustomerSupportGateway.GatewayIdentifier
          RESOURCE_ARN: !GetAtt CustomerSupportGateway.GatewayArn
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  region = os.environ['REGION']
                  resource_id = os.environ['RESOURCE_ID']
                  resource_arn = os.environ['RESOURCE_ARN']

                  logs_client = boto3.client('logs', region_name=region)

                  if request_type == 'Create':
                      logger.info("Setting up X-Ray traces delivery")

                      # Create delivery source for traces
                      traces_source_response = logs_client.put_delivery_source(
                          name=f"{resource_id}-traces-source",
                          logType="TRACES",
                          resourceArn=resource_arn
                      )
                      logger.info(f"Created delivery source: {traces_source_response['deliverySource']['name']}")

                      # Set delivery destination in XRAY
                      traces_destination_response = logs_client.put_delivery_destination(
                          name=f"{resource_id}-traces-destination",
                          deliveryDestinationType='XRAY'
                      )
                      logger.info(f"Created delivery destination: {traces_destination_response['deliveryDestination']['name']}")

                      # Create delivery
                      traces_delivery = logs_client.create_delivery(
                          deliverySourceName=traces_source_response['deliverySource']['name'],
                          deliveryDestinationArn=traces_destination_response['deliveryDestination']['arn']
                      )
                      logger.info(f"Created delivery: {traces_delivery['delivery']['id']}")

                      send_response(event, context, 'SUCCESS', {
                          'DeliveryId': traces_delivery['delivery']['id']
                      })

                  elif request_type == 'Delete':
                      logger.info("Cleaning up X-Ray traces delivery resources")

                      try:
                          # Delete delivery first
                          try:
                              logs_client.delete_delivery(
                                  id=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery: {str(e)}")

                          # Delete delivery destination
                          try:
                              logs_client.delete_delivery_destination(
                                  name=f"{resource_id}-traces-destination"
                              )
                              logger.info(f"Deleted delivery destination")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery destination not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery destination: {str(e)}")

                          # Delete delivery source
                          try:
                              logs_client.delete_delivery_source(
                                  name=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery source")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery source not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery source: {str(e)}")

                      except Exception as e:
                          logger.error(f"Error during cleanup: {str(e)}")
                          # Continue with SUCCESS to allow stack deletion

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}", exc_info=True)
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'XRayTracesSetup',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Function'

  # Custom Resource to Setup X-Ray Traces
  XRayTracesSetup:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CustomerSupportGateway
    Properties:
      ServiceToken: !GetAtt XRayTracesSetupFunction.Arn

  AgentGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupClass: STANDARD
      LogGroupName: !Sub "/aws/vendedlogs/bedrock-agentcore/${CustomerSupportGateway.GatewayIdentifier}"

  AgentGatewayDeliverSourceApplicationLogs:
    Type: AWS::Logs::DeliverySource
    Properties:
      LogType: APPLICATION_LOGS
      Name: !Sub "${CustomerSupportGateway.GatewayIdentifier}-logs-source"
      ResourceArn: !GetAtt CustomerSupportGateway.GatewayArn

  AgentGatewayDeliveryDestination:
    Type: AWS::Logs::DeliveryDestination
    Properties:
      DeliveryDestinationType: "CWL"
      DestinationResourceArn: !GetAtt AgentGatewayLogGroup.Arn
      Name: !Sub "${CustomerSupportGateway.GatewayIdentifier}-logs-destination"

  AgentGatewayDeliveryApplicationLogs:
    Type: AWS::Logs::Delivery
    Properties:
      DeliveryDestinationArn: !GetAtt AgentGatewayDeliveryDestination.Arn
      DeliverySourceName: !Sub "${CustomerSupportGateway.GatewayIdentifier}-logs-source"


  LambdaCustomerSupportTarget:
    Type: AWS::BedrockAgentCore::GatewayTarget
    Properties:
      CredentialProviderConfigurations:
        - CredentialProviderType: GATEWAY_IAM_ROLE
      Description: "Customer Support Lambda Target with warranty checks and customer profile lookups"
      GatewayIdentifier: !GetAtt CustomerSupportGateway.GatewayIdentifier
      Name: !Sub '${Environment}-customer-support-vpc'
      TargetConfiguration:
        Mcp:
          Lambda:
            LambdaArn: !GetAtt CustomerSupportLambda.Arn
            ToolSchema:
              InlinePayload:
                - Name: "get_customer_profile"
                  Description: "Retrieve customer profile using customer ID, email, or phone number"
                  InputSchema:
                    Type: "object"
                    Properties:
                      customer_id:
                        Type: "string"
                        Description: "Customer ID (e.g., CUST001)"
                      email:
                        Type: "string"
                        Description: "Customer email address"
                      phone:
                        Type: "string"
                        Description: "Customer phone number"
                    Required:
                      - "customer_id"
                  OutputSchema:
                    Type: "object"
                    Properties:
                      statusCode:
                        Type: "integer"
                        Description: "HTTP status code"
                      body:
                        Type: "string"
                        Description: "Customer profile information"
                - Name: "check_warranty_status"
                  Description: "Check the warranty status of a product using its serial number and optionally verify via email"
                  InputSchema:
                    Type: "object"
                    Properties:
                      serial_number:
                        Type: "string"
                        Description: "Product serial number (8-20 alphanumeric characters)"
                      customer_email:
                        Type: "string"
                        Description: "Customer email for verification (optional)"
                    Required:
                      - "serial_number"
                  OutputSchema:
                    Type: "object"
                    Properties:
                      statusCode:
                        Type: "integer"
                        Description: "HTTP status code"
                      body:
                        Type: "string"
                        Description: "Warranty status information"



  # Gateway Management Lambda Function
  GatewayManagementFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-gateway-management'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt GatewayManagementLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          GATEWAY_SECRET_ARN:
              Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientSecret'
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import cfnresponse
          import logging
          from botocore.exceptions import ClientError

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event, default=str)}")

                  request_type = event['RequestType']
                  properties = event['ResourceProperties']

                  # Initialize Bedrock AgentCore client
                  identity_client = boto3.client('bedrock-agentcore-control')

                  if request_type == 'Create':
                      response_data = create_credential_provider(identity_client, properties)
                  elif request_type == 'Delete':
                      response_data = delete_credential_provider(identity_client, properties)
                  else:
                      response_data = {'Message': f'No action taken for request type: {request_type}'}

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  logger.error(f"Error in gateway management: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

          def create_credential_provider(identity_client, properties):
              """Create OAuth2 credential provider for Gateway authentication"""
              try:
                  provider_name = properties['ProviderName']

                  # Get client credentials from Secrets Manager
                  secrets_client = boto3.client('secretsmanager')
                  secret_arn = os.environ['GATEWAY_SECRET_ARN']

                  secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
                  secret_data = json.loads(secret_response['SecretString'])

                  client_id = secret_data['client_id']
                  client_secret = secret_data['client_secret']
                  token_url = secret_data['token_endpoint']
                  auth_url = properties['DiscoveryUrl'].replace('/.well-known/openid-configuration', '/oauth2/authorize')

                  # Create OAuth2 credential provider
                  identity_client.create_oauth2_credential_provider(
                      name=provider_name,
                      credentialProviderVendor="CustomOauth2",
                      oauth2ProviderConfigInput={
                          "customOauth2ProviderConfig": {
                              "clientId": client_id,
                              "clientSecret": client_secret,
                              "oauthDiscovery": {
                                  "authorizationServerMetadata": {
                                      "issuer": properties['DiscoveryUrl'],
                                      "authorizationEndpoint": auth_url,
                                      "tokenEndpoint": token_url,
                                      "responseTypes": ["code", "token"],
                                  }
                              },
                          }
                      },
                  )

                  logger.info(f"OAuth2 credential provider created successfully: {provider_name}")

                  return {
                      'Message': 'oauth2_credential_provider created successfully',
                      'ProviderName': provider_name
                  }

              except Exception as e:
                  logger.error(f"Error creating oauth2_credential_provider: {str(e)}")
                  raise

          def delete_credential_provider(identity_client, properties):
              """Delete OAuth2 credential provider"""
              try:
                  provider_name = properties['ProviderName']
                  identity_client.delete_oauth2_credential_provider(name=provider_name)
                  logger.info(f"OAuth2 credential provider deleted: {provider_name}")

                  return {
                      'Message': f'OAuth2 credential provider {provider_name} deleted successfully'
                  }

              except Exception as e:
                  logger.error(f"Error deleting oauth2_credential_provider: {str(e)}")
                  raise

  # Lambda Function to Populate Synthetic Data
  PopulateDataFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-populate-data'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt PopulateDataLambdaRole.Arn
      Timeout: 120
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          from datetime import datetime, timedelta
          import uuid
          from decimal import Decimal

          def lambda_handler(event, context):
              dynamodb = boto3.resource('dynamodb')

              try:
                  if event['RequestType'] == 'Create':
                      # Get table references
                      warranty_table = dynamodb.Table(event['ResourceProperties']['WarrantyTableName'])
                      customer_table = dynamodb.Table(event['ResourceProperties']['CustomerTableName'])

                      # Sample warranty data
                      warranty_data = [
                          {
                              'serial_number': 'LAPTOP001A1B2C',
                              'product_name': 'TechCorp Laptop Pro 15',
                              'purchase_date': '2023-08-15',
                              'warranty_end_date': '2025-08-15',
                              'warranty_type': 'Extended',
                              'customer_name': 'John Doe',
                              'coverage_details': 'Comprehensive coverage including accidental damage, hardware defects, and software support'
                          },
                          {
                              'serial_number': 'PHONE002X1Y2Z',
                              'product_name': 'TechCorp Smartphone X12',
                              'purchase_date': '2024-01-10',
                              'warranty_end_date': '2025-01-10',
                              'warranty_type': 'Standard',
                              'customer_name': 'Jane Smith',
                              'coverage_details': 'Standard hardware warranty covering manufacturing defects'
                          },
                          {
                              'serial_number': 'TABLET003M5N6P',
                              'product_name': 'TechCorp Tablet Air',
                              'purchase_date': '2023-12-05',
                              'warranty_end_date': '2024-12-05',
                              'warranty_type': 'Premium',
                              'customer_name': 'Bob Johnson',
                              'coverage_details': 'Premium warranty with priority support and extended coverage'
                          },
                          {
                              'serial_number': 'WATCH004Q7R8S',
                              'product_name': 'TechCorp Smart Watch',
                              'purchase_date': '2024-03-20',
                              'warranty_end_date': '2025-03-20',
                              'warranty_type': 'Standard',
                              'customer_name': 'Alice Brown',
                              'coverage_details': 'Standard warranty covering hardware defects and battery issues'
                          },
                          {
                              'serial_number': 'CAMERA005T9U1V',
                              'product_name': 'TechCorp Camera Pro',
                              'purchase_date': '2022-06-15',
                              'warranty_end_date': '2024-06-15',
                              'warranty_type': 'Extended',
                              'customer_name': 'Charlie Davis',
                              'coverage_details': 'Extended warranty with professional equipment coverage'
                          }
                      ]

                      # Sample customer data - linked to Aurora users via customer_id
                      customer_data = [
                          {
                              'customer_id': 'CUST001',
                              'first_name': 'John',
                              'last_name': 'Doe',
                              'email': 'john.doe@email.com',
                              'phone': '+1-555-0101',
                              'address': {
                                  'street': '123 Tech Street',
                                  'city': 'San Francisco',
                                  'state': 'CA',
                                  'zip_code': '94105',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1985-03-15',
                              'registration_date': '2022-01-15',
                              'tier': 'Premium',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': True,
                                  'phone': False
                              },
                              'support_cases_count': 2,
                              'total_purchases': 5,
                              'lifetime_value': Decimal('3250.99'),
                              'notes': 'VIP customer, prefers email communication'
                          },
                          {
                              'customer_id': 'CUST002',
                              'first_name': 'Jane',
                              'last_name': 'Smith',
                              'email': 'jane.smith@email.com',
                              'phone': '+1-555-0102',
                              'address': {
                                  'street': '456 Innovation Ave',
                                  'city': 'Austin',
                                  'state': 'TX',
                                  'zip_code': '73301',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1990-07-22',
                              'registration_date': '2023-03-10',
                              'tier': 'Gold',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': False,
                                  'phone': True
                              },
                              'support_cases_count': 1,
                              'total_purchases': 3,
                              'lifetime_value': Decimal('1899.50'),
                              'notes': 'Tech enthusiast, quick to adopt new products'
                          },
                          {
                              'customer_id': 'CUST003',
                              'first_name': 'Bob',
                              'last_name': 'Johnson',
                              'email': 'bob.johnson@email.com',
                              'phone': '+1-555-0103',
                              'address': {
                                  'street': '789 Digital Blvd',
                                  'city': 'Seattle',
                                  'state': 'WA',
                                  'zip_code': '98101',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1978-11-08',
                              'registration_date': '2021-09-05',
                              'tier': 'VIP',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': True,
                                  'phone': True
                              },
                              'support_cases_count': 5,
                              'total_purchases': 12,
                              'lifetime_value': Decimal('8750.25'),
                              'notes': 'Long-term customer, business account holder'
                          },
                          {
                              'customer_id': 'CUST004',
                              'first_name': 'Alice',
                              'last_name': 'Brown',
                              'email': 'alice.brown@email.com',
                              'phone': '+1-555-0104',
                              'address': {
                                  'street': '321 Future Lane',
                                  'city': 'New York',
                                  'state': 'NY',
                                  'zip_code': '10001',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1995-01-30',
                              'registration_date': '2024-01-20',
                              'tier': 'Standard',
                              'communication_preferences': {
                                  'email': True,
                                  'sms': False,
                                  'phone': False
                              },
                              'support_cases_count': 0,
                              'total_purchases': 1,
                              'lifetime_value': Decimal('299.99'),
                              'notes': 'New customer, fitness enthusiast'
                          },
                          {
                              'customer_id': 'CUST005',
                              'first_name': 'Charlie',
                              'last_name': 'Davis',
                              'email': 'charlie.davis@email.com',
                              'phone': '+1-555-0105',
                              'address': {
                                  'street': '654 Creative Circle',
                                  'city': 'Los Angeles',
                                  'state': 'CA',
                                  'zip_code': '90210',
                                  'country': 'USA'
                              },
                              'date_of_birth': '1982-09-12',
                              'registration_date': '2020-06-15',
                              'tier': 'Gold',
                              'communication_preferences': {
                                  'email': False,
                                  'sms': True,
                                  'phone': True
                              },
                              'support_cases_count': 3,
                              'total_purchases': 7,
                              'lifetime_value': Decimal('4200.75'),
                              'notes': 'Professional photographer, values quality'
                          }
                      ]

                      # Populate warranty table
                      for item in warranty_data:
                          warranty_table.put_item(Item=item)

                      # Populate customer table
                      for item in customer_data:
                          customer_table.put_item(Item=item)

                      print("Successfully populated sample data")

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})

  # IAM Role for Populate Data Lambda
  PopulateDataLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PopulateDataPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:BatchWriteItem
                Resource:
                  - !GetAtt WarrantyTable.Arn
                  - !GetAtt CustomerProfileTable.Arn
              - Effect: Allow
                Action:
                  - kms:Encrypt
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource: !GetAtt GatewayDynamoDBKMSKey.Arn

  # Custom Resource to Populate Data
  PopulateDataResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt PopulateDataFunction.Arn
      WarrantyTableName: !Ref WarrantyTable
      CustomerTableName: !Ref CustomerProfileTable

  # Custom Resource to Manage Gateway
  GatewayManagementResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - CustomerSupportLambda
    Properties:
      ServiceToken: !GetAtt GatewayManagementFunction.Arn
      ProviderName: !Sub 'GatewayOAuth2Provider-csvpc-${Environment}'
      DiscoveryUrl: !Sub
        - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
        - UserPoolId:
            Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'

  # Main Customer Support Lambda Function
  CustomerSupportLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-customer-support'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt CustomerSupportLambdaRole.Arn
      Timeout: 30
      VpcConfig:
        SecurityGroupIds:
          - Fn::ImportValue: !Sub '${VPCStackName}-GatewayLambdaSecurityGroup'
        SubnetIds:
          - Fn::ImportValue: !Sub '${VPCStackName}-PrivateSubnet2'
      Code:
        ZipFile: |
          import boto3
          import json
          import re
          from datetime import datetime
          from botocore.exceptions import ClientError
          import logging

          # Setting logger
          logging.basicConfig(
              format="[%(asctime)s] p%(process)s {%(filename)s:%(lineno)d} %(levelname)s - %(message)s",
              level=logging.INFO,
          )
          logger = logging.getLogger(__name__)

          # Initialize clients
          dynamodb = boto3.resource("dynamodb")
          ssm_client = boto3.client("ssm")

          def get_named_parameter(event, name):
              if name not in event:
                  return None
              return event.get(name)

          def get_customer_profile(customer_id=None, email=None, phone=None):
              """Get customer profile information"""
              try:
                  # Get customer profile table name from Parameter Store
                  customer_table = ssm_client.get_parameter(
                      Name="/app/customersupportvpc/dynamodb/customer_profile_table_name",
                      WithDecryption=False,
                  )
                  customer_table_name = customer_table["Parameter"]["Value"]
                  table = dynamodb.Table(customer_table_name)

                  customer_item = None
                  search_method = ""

                  # Search by customer_id (primary key - most efficient)
                  if customer_id:
                      search_method = "Customer ID"
                      response = table.get_item(Key={"customer_id": customer_id.upper()})
                      if "Item" in response:
                          customer_item = response["Item"]

                  # Search by email using GSI
                  elif email:
                      search_method = "Email"
                      response = table.query(
                          IndexName="email-index",
                          KeyConditionExpression="email = :email",
                          ExpressionAttributeValues={":email": email.lower()},
                      )
                      if response["Items"]:
                          customer_item = response["Items"][0]

                  # Search by phone using GSI
                  elif phone:
                      search_method = "Phone"
                      normalized_phone = re.sub(r"[\s\-$$]", "", phone)
                      if not normalized_phone.startswith("+"):
                          normalized_phone = "+1-" + normalized_phone if len(normalized_phone) == 10 else phone

                      response = table.query(
                          IndexName="phone-index",
                          KeyConditionExpression="phone = :phone",
                          ExpressionAttributeValues={":phone": normalized_phone},
                      )
                      if response["Items"]:
                          customer_item = response["Items"][0]

                  if not customer_item:
                      return f"‚ùå Customer not found using {search_method}: {customer_id or email or phone}"

                  # Format customer profile response
                  customer_id_value = customer_item.get("customer_id", "Unknown")
                  first_name = customer_item.get("first_name", "Unknown")
                  last_name = customer_item.get("last_name", "Unknown")
                  email_value = customer_item.get("email", "Not provided")
                  phone_value = customer_item.get("phone", "Not provided")
                  tier = customer_item.get("tier", "Standard")
                  total_purchases = customer_item.get("total_purchases", 0)
                  lifetime_value = float(customer_item.get("lifetime_value", 0))

                  tier_emoji = {"Standard": "ü•â", "Gold": "ü•á", "Premium": "üíé", "VIP": "üëë"}.get(tier, "üë§")

                  profile_info = [
                      "üë§ Customer Profile Information",
                      "===============================",
                      f"üÜî Customer ID: {customer_id_value}",
                      f"üë§ Name: {first_name} {last_name}",
                      f"{tier_emoji} Tier: {tier}",
                      f"üìß Email: {email_value}",
                      f"üì± Phone: {phone_value}",
                      f"üõí Total Purchases: {total_purchases}",
                      f"üí∞ Lifetime Value: ${lifetime_value:,.2f}",
                  ]

                  return "\n".join(profile_info)

              except Exception as e:
                  logger.error(f"Error getting customer profile: {str(e)}")
                  return f"‚ùå Error retrieving customer profile: {str(e)}"

          def check_warranty_status(serial_number, customer_email=None):
              """Check warranty status for a product"""
              try:
                  # Get warranty table name from Parameter Store
                  warranty_table = ssm_client.get_parameter(
                      Name="/app/customersupportvpc/dynamodb/warranty_table_name",
                      WithDecryption=False
                  )
                  warranty_table_name = warranty_table["Parameter"]["Value"]
                  table = dynamodb.Table(warranty_table_name)

                  # Validate serial number format
                  if not re.match(r"^[A-Z0-9]{8,20}$", serial_number.upper()):
                      return "‚ùå Invalid serial number format. Must be 8-20 alphanumeric characters."

                  serial_number = serial_number.upper()
                  response = table.get_item(Key={"serial_number": serial_number})

                  if "Item" not in response:
                      return f"‚ùå Warranty not found for serial number: {serial_number}"

                  warranty_item = response["Item"]

                  # Extract warranty information
                  product_name = warranty_item.get("product_name", "Unknown Product")
                  purchase_date = warranty_item.get("purchase_date", "Unknown")
                  warranty_end_date = warranty_item.get("warranty_end_date", "Unknown")
                  warranty_type = warranty_item.get("warranty_type", "Standard")
                  customer_name = warranty_item.get("customer_name", "Unknown")
                  coverage_details = warranty_item.get("coverage_details", "Standard coverage applies")

                  # Calculate days remaining
                  try:
                      end_date_obj = datetime.strptime(warranty_end_date, "%Y-%m-%d")
                      today = datetime.now()
                      days_remaining = (end_date_obj - today).days
                  except ValueError:
                      days_remaining = 0

                  # Determine status
                  if days_remaining > 30:
                      status_text = "‚úÖ Active"
                  elif days_remaining > 0:
                      status_text = "‚ö†Ô∏è Expiring Soon"
                  else:
                      status_text = "‚ùå Expired"

                  # Format warranty information
                  warranty_info = [
                      "üõ°Ô∏è Warranty Status Information",
                      "===============================",
                      f"üì± Product: {product_name}",
                      f"üî¢ Serial Number: {serial_number}",
                      f"üë§ Customer: {customer_name}",
                      f"üìÖ Purchase Date: {purchase_date}",
                      f"‚è∞ Warranty End Date: {warranty_end_date}",
                      f"üìã Warranty Type: {warranty_type}",
                      f"üîç Status: {status_text}",
                      f"üìÜ Days Remaining: {days_remaining if days_remaining > 0 else 'Expired'}",
                      "",
                      "üîß Coverage Details:",
                      f"   {coverage_details}",
                  ]

                  return "\n".join(warranty_info)

              except Exception as e:
                  logger.error(f"Error checking warranty status: {str(e)}")
                  return f"‚ùå Error checking warranty status: {str(e)}"

          def lambda_handler(event, context):
              print(f"Event: {event}")
              print(f"Context: {context}")

              try:
                  extended_tool_name = context.client_context.custom["bedrockAgentCoreToolName"]
                  resource = extended_tool_name.split("___")[1]

                  print(f"Resource: {resource}")

                  if resource == "get_customer_profile":
                      customer_id = get_named_parameter(event=event, name="customer_id")
                      email = get_named_parameter(event=event, name="email")
                      phone = get_named_parameter(event=event, name="phone")

                      if not customer_id and not email and not phone:
                          return {
                              "statusCode": 400,
                              "body": "‚ùå Please provide customer_id, email, or phone",
                          }

                      customer_profile = get_customer_profile(
                          customer_id=customer_id, email=email, phone=phone
                      )

                      return {
                          "statusCode": 200,
                          "body": customer_profile,
                      }

                  elif resource == "check_warranty_status":
                      serial_number = get_named_parameter(event=event, name="serial_number")
                      customer_email = get_named_parameter(event=event, name="customer_email")

                      if not serial_number:
                          return {
                              "statusCode": 400,
                              "body": "‚ùå Please provide serial_number",
                          }

                      warranty_status = check_warranty_status(
                          serial_number=serial_number, customer_email=customer_email
                      )

                      return {
                          "statusCode": 200,
                          "body": warranty_status,
                      }

                  return {
                      "statusCode": 400,
                      "body": f"‚ùå Unknown toolname: {resource}",
                  }

              except Exception as e:
                  logger.error(f"Lambda handler error: {str(e)}")
                  return {
                      "statusCode": 500,
                      "body": f"‚ùå Internal error: {str(e)}",
                  }

  # SSM Parameters for table names
  CustomerProfileTableNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/dynamodb/customer_profile_table_name
      Type: String
      Value: !Ref CustomerProfileTable
      Description: 'Customer Profile DynamoDB Table Name'

  WarrantyTableNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/dynamodb/warranty_table_name
      Type: String
      Value: !Ref WarrantyTable
      Description: 'Warranty DynamoDB Table Name'


  # SSM Parameter for Lambda Function ARN
  CustomerSupportLambdaArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/lambda/customer_support_lambda_arn
      Type: String
      Value: !GetAtt CustomerSupportLambda.Arn
      Description: 'Customer Support Lambda Function ARN'

  GatewayAgentcoreIAMRoleParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/agentcore/gateway_iam_role
      Type: String
      Value: !GetAtt GatewayAgentCoreRole.Arn
      Description: agentcore IAM role to assume
      Tags:
        Application: CustomerSupport

  # SSM Parameters for Gateway Information
  GatewayIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/gateway/gateway_id
      Type: String
      Value: !GetAtt CustomerSupportGateway.GatewayIdentifier
      Description: 'Customer Support Gateway ID'

  GatewayArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/gateway/gateway_arn
      Type: String
      Value: !GetAtt CustomerSupportGateway.GatewayArn
      Description: 'Customer Support Gateway ARN'

  GatewayUrlParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/gateway/gateway_url
      Type: String
      Value: !GetAtt CustomerSupportGateway.GatewayUrl
      Description: 'Customer Support Gateway URL'

  GatewayOAuth2ProviderNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/gateway/oauth2_provider_name
      Type: String
      Value: !Sub 'GatewayOAuth2Provider-csvpc-${Environment}'
      Description: 'OAuth2 Credential Provider Name for Gateway Authentication'

Outputs:
  StackName:
    Description: 'Stack name for cross-stack references'
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'

  CustomerProfileTableName:
    Description: 'Customer Profile DynamoDB Table Name'
    Value: !Ref CustomerProfileTable
    Export:
      Name: !Sub '${AWS::StackName}-CustomerProfileTable'

  WarrantyTableName:
    Description: 'Warranty DynamoDB Table Name'
    Value: !Ref WarrantyTable
    Export:
      Name: !Sub '${AWS::StackName}-WarrantyTable'

  GatewayId:
    Description: 'Customer Support Gateway ID'
    Value: !GetAtt CustomerSupportGateway.GatewayIdentifier
    Export:
      Name: !Sub '${AWS::StackName}-GatewayIdentifier'

  GatewayArn:
    Description: 'Customer Support Gateway ARN'
    Value: !GetAtt CustomerSupportGateway.GatewayArn
    Export:
      Name: !Sub '${AWS::StackName}-GatewayArn'

  GatewayUrl:
    Description: 'Customer Support Gateway URL'
    Value: !GetAtt CustomerSupportGateway.GatewayUrl
    Export:
      Name: !Sub '${AWS::StackName}-GatewayUrl'

  GatewayTargetId:
    Description: 'Customer Support Gateway Target ID'
    Value: !GetAtt LambdaCustomerSupportTarget.TargetId
    Export:
      Name: !Sub '${AWS::StackName}-TargetId'

